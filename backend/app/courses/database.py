import os
from typing import Optional, Dict, Any, List

import psycopg
from psycopg import Connection
from psycopg.rows import dict_row

DATABASE_URL = os.environ["DATABASE_URL"]

if not DATABASE_URL:
    raise RuntimeError("DATABASE_URL IS NOT SET")

# status is 0, 1, or 2:
# - 0 = not started
# - 1 = started
# - 2 = finished
PG_SCHEMA = """
CREATE TABLE IF NOT EXISTS users (
  id              INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  username        TEXT UNIQUE,
  password_hash   TEXT NOT NULL,
  email           TEXT,
  prefers_light   BOOL DEFAULT TRUE
);

CREATE TABLE IF NOT EXISTS courses (
  id          INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id     INTEGER NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  slug        TEXT UNIQUE,
  title       TEXT NOT NULL,
  description TEXT NOT NULL,
  status      INTEGER NOT NULL,
  UNIQUE(user_id, title)
);

CREATE TABLE IF NOT EXISTS sections (
  id        INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  course_id INTEGER NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
  title     TEXT NOT NULL,
  summary   TEXT,
  position  INTEGER NOT NULL,
  status    INTEGER NOT NULL,
  UNIQUE(course_id, position)
);

CREATE TABLE IF NOT EXISTS lessons (
  id            INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  course_id     INTEGER NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
  section_id    INTEGER REFERENCES sections(id) ON DELETE SET NULL,
  title         TEXT NOT NULL,
  description   TEXT NOT NULL,
  body_md       TEXT,
  messages      TEXT,
  summary       TEXT,
  position      INTEGER NOT NULL,
  status        INTEGER NOT NULL,
  UNIQUE(section_id, position)
);

CREATE TABLE IF NOT EXISTS exercises (
  id            INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  lesson_id     INTEGER,
  exercise      TEXT,
  solution      TEXT,
  UNIQUE(lesson_id, id)
);

CREATE TABLE IF NOT EXISTS quizzes (
  id            INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  course_id     INTEGER NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
  section_id    INTEGER REFERENCES sections(id) ON DELETE SET NULL,
  quiz          TEXT,
  options       TEXT,
  answer        INTEGER,
  position      INTEGER NOT NULL,
  status        INTEGER NOT NULL,
  UNIQUE(course_id, position)
);

CREATE TABLE IF NOT EXISTS projects (
  id         INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  course_id  INTEGER NOT NULL REFERENCES courses(id) ON DELETE CASCADE,
  section_id INTEGER REFERENCES sections(id) ON DELETE SET NULL,
  brief      TEXT NOT NULL,
  position   INTEGER NOT NULL,
  status     INTEGER NOT NULL,
  UNIQUE(course_id, position)
);

"""

def init_db():
    """Create DB and schema if not present."""
    with psycopg.connect(DATABASE_URL) as con:
        with con.cursor() as cur:
            cur.execute(PG_SCHEMA)

def open_db():
    return psycopg.connect(DATABASE_URL, row_factory=dict_row)

def create_course(con: Connection, user_id: int, title: str, slug: Optional[str] = None, description: Optional[str] = None) -> int:
    with con.cursor() as cur:
        cur.execute(
            "INSERT INTO courses(user_id, title, slug, description, status) VALUES (%s, %s, %s, %s, 0) RETURNING id",
            (user_id, title, slug, description),
        )
        new_id = cur.fetchone()["id"]
    con.commit()
    return new_id

def create_section(con: Connection, course_id: int, title: str, position: int) -> int:
    with con.cursor() as cur:
        cur.execute(
            "INSERT INTO sections(course_id, title, position, status) VALUES (%s, %s, %s, 0) RETURNING id",
            (course_id, title, position),
        )
        new_id = cur.fetchone()["id"]
    con.commit()
    return new_id

def create_lesson(con: Connection, course_id: int, section_id: int, title: str, description: str, position: int, body_md: Optional[str] = None):
    with con.cursor() as cur:
        cur.execute(
            "INSERT INTO lessons(course_id, section_id, title, description, body_md, position, status)"
            " VALUES (%s, %s, %s, %s, %s, %s, 0)",
            (course_id, section_id, title, description, body_md, position),
        )
    con.commit()

def get_all_courses(con: Connection, user_id: int) -> List[Dict[str, Any]]:
    with con.cursor() as cur:
        cur.execute(
            """
            SELECT
                c.id            AS id,
                c.title         AS title,
                c.description   AS description,
                c.status        AS status,
                (SELECT COUNT(*)
                    FROM sections s
                    WHERE s.course_id = c.id)
                                AS section_count
            FROM courses AS c
            WHERE c.user_id = %s
            ORDER BY c.id DESC;
            """,
            (user_id,)
        )
        rows = cur.fetchall()

    return rows

def get_sections(con: Connection, course_id: int):
    with con.cursor() as cur:
        cur.execute(
            """
            SELECT
                s.id        AS id,
                s.title     AS title,
                s.status    AS status,
                (SELECT COUNT(*)
                    FROM lessons l
                    WHERE l.section_id = s.id)
                            AS lesson_count
            FROM sections AS s
            WHERE s.course_id = %s
            ORDER BY s.position;
            """,
            (course_id,),
        )
        rows = cur.fetchall()
    return rows

def get_lessons(con: Connection, section_id: int):
    with con.cursor() as cur:
        cur.execute(
            """
            SELECT
                l.id                       AS id,
                l.title                    AS title,
                l.description              AS description,
                l.body_md                  AS body_md,
                l.messages                 AS messages,
                l.status                   AS status
            FROM lessons AS l
            WHERE l.section_id = %s
            ORDER BY l.position;
            """,
            (section_id,),
        )
        rows = cur.fetchall()
    return rows

def get_single_lesson(con: Connection, lesson_id: int):
    with con.cursor() as cur:
        cur.execute(
            """
            SELECT
                l.id            AS id,
                l.course_id     AS course_id,
                l.section_id    AS section_id,
                l.title         AS title,
                l.description   AS description,
                l.body_md       AS body_md,
                l.messages      AS messages,
                l.summary       AS summary,
                l.position      AS position,
                l.status        AS status
            FROM lessons AS l
            WHERE l.id = %s
            """,
            (lesson_id,),
        )
        lesson = cur.fetchone()
    return lesson 

def update_lesson_sql(con: Connection, l: dict):
    with con.cursor() as cur:
        cur.execute(
            """
            UPDATE lessons
            SET
                title       = %s,
                description = %s,
                body_md     = %s,
                messages    = %s,
                summary     = %s,
                status      = %s
            WHERE id = %s
            """,
            (
                l["title"], l["description"], l["body_md"],
                l["messages"], l["summary"], l["status"], l["id"],
            ),
        )
    con.commit()

def get_course_info(con: Connection, course_id: int):
    print("made it into get_course_info")
    with con.cursor() as cur:
        cur.execute(
            """
            SELECT
                c.title         AS title,
                c.description   AS description
            FROM courses AS c
            WHERE c.id = %s
            """,
            (course_id,),
        )
        course = cur.fetchone()
    return course["title"], course["description"]

def get_summaries(con: Connection, c_id: int, s_id: int, l_pos: int):
# if lesson's position = 1 and its section's position = 1,
# this is the start of the course
#
# if lesson's position = 1 and its section's position > 1,
# pull summaries from previous section(s)
#
# if lesson's position > 1 and its section's position = 1,
# pull summaries from previous lessons in the section
#
# if lesson's position > 1 and its section's position > 1,
# pull summaries from previous lessons in the section and previous sections
    print("made it into get_summaries")
    with con.cursor() as cur:
        # first check if there are prior sections or lessons
        cur.execute(
            """
            SELECT position AS sec_pos
            FROM sections
            WHERE id = %s
            """,
            (s_id,),
        )
        row = cur.fetchone()
        if row is None:
            return ""
        sec_pos = row["sec_pos"]
        if sec_pos == 1 and l_pos == 1:
            return ""

        cur.execute(
            """
            WITH cur AS (
                SELECT 
                    id       AS section_id, 
                    course_id, 
                    position AS sec_pos
                FROM sections
                WHERE id = %(sid)s
            ),
            prev_sections AS (
                SELECT 
                    s.id       AS section_id, 
                    s.position AS sec_pos
                FROM sections s
                JOIN cur ON s.course_id = cur.course_id
                WHERE s.position < cur.sec_pos
            ),
            stream AS (
                SELECT
                    s.position  AS sec_pos,
                    0           AS kind_rank,
                    NULL        AS lesson_pos,
                    s.summary   AS text
                FROM sections s
                JOIN prev_sections ps ON ps.section_id = s.id
            
                UNION ALL

                SELECT
                    cur.sec_pos AS sec_pos,
                    1           AS kind_rank,
                    l.position  AS lesson_pos,
                    l.summary   AS text
                FROM lessons l
                JOIN cur ON l.section_id = cur.section_id
                WHERE l.position < %(lpos)s
            )
            SELECT sec_pos, kind_rank, lesson_pos, text
            FROM stream
            ORDER BY sec_pos ASC, kind_rank ASC, lesson_pos ASC
            """,
            {"sid": s_id, "lpos": l_pos},
        )
        rows = cur.fetchall()
    
    pieces: list[str] = []
    for r in rows:
        txt = r["text"]
        if txt:
            t = txt.strip()
            if t:
                pieces.append(t)

    return "\n\n".join(pieces)

def get_future_lessons(con: Connection, c_id: int, s_id: int, l_pos: int):
# pull all titles from lessons after l_pos to the end of the section
    pass

def create_user(con: Connection, username: str, password: str):
    with con.cursor() as cur:
        cur.execute(
            "INSERT INTO users(username, password_hash) VALUES (%s, %s) RETURNING id",
            (username, password),
        )
        new_id = cur.fetchone()["id"]
    con.commit()

def get_user_by_username(con: Connection, username: str):
    with con.cursor() as cur:
        cur.execute(
            """
            SELECT
                u.id            AS id,
                u.username      AS username,
                u.password_hash AS password_hash
            FROM users AS u
            WHERE u.username = %s
            """,
            (username,),
        )
        user = cur.fetchone()
    return user

def get_user_by_id(con: Connection, uid: int):
    with con.cursor() as cur:
        cur.execute(
            """
            SELECT
                u.id            AS id,
                u.username      AS username,
                u.password_hash AS password_hash,
                u.email         AS email,
                u.prefers_light AS prefers_light
            FROM users AS U
            WHERE u.id = %s
            """,
            (uid,),
        )
        user = cur.fetchone()
    return user

def push_exercise_to_sql(con: Connection, cid: int, sid: int, lid: int, exercise: str, answer: str):
    with con.cursor() as cur:
        cur.execute(
            "INSERT INTO exercises(course_id, section_id, lesson_id, exercise, answer, explanation) VALUES (%s, %s, %s, %s, %s)",
            (cid, sid, lid, exercise, answer),
        )
    con.commit()

def get_exercise(con: Connection, eid: int) -> Dict[str, Any]:
    with con.cursor() as cur:
        cur.execute("""
            SELECT
                e.exercise      as exercise,
                e.solution      as solution,
            FROM exercises AS e
            WHERE
                e.id = %s
            """,
            (cid, sid, lid, eid),
        )
        exercise = cur.fetchone()
    return exercise

def get_all_exercises(con: Connection, lid: int) -> List[Dict[str, Any]]:
    with con.cursor() as cur:
        cur.execute("""
            SELECT
                e.id as id
            FROM exercises AS e
            WHERE
                e.lesson_id = %s
            """,
            (cid, sid, lid),
        )
        rows = cur.fetchall()
    return rows
